
---

# ğŸ§± LEVEL 1 â€” Basics (Warm-up, but strict Rust)

### Variables & Control

1. Read `n`, print sum of first `n` numbers
2. Print all even numbers â‰¤ `n`
3. Reverse an integer
4. Count digits of a number
5. Check palindrome number
6. Power of a number (`a^b`) without `pow()`
7. Fibonacci (iterative)
8. Fibonacci (recursive)
9. Factorial using loop
10. Factorial using recursion

---

# ğŸ§® LEVEL 2 â€” Arrays & Slices (Ownership test)

11. Find maximum in array
12. Find minimum in array
13. Reverse array in-place
14. Rotate array by `k`
15. Check if array is sorted
16. Remove duplicates from sorted array
17. Merge two sorted arrays
18. Find second largest element
19. Count frequency of elements
20. Move all zeros to end

---

# ğŸ§µ LEVEL 3 â€” Strings (UTF-8 pain zone)

21. Reverse string
22. Check palindrome string
23. Count vowels and consonants
24. Find first non-repeating character
25. Check anagram
26. Longest common prefix
27. Remove duplicate characters
28. Check valid parentheses
29. Implement `atoi`
30. Longest substring without repeating characters

---

# ğŸ§  LEVEL 4 â€” Searching & Sorting

### Searching

31. Linear search
32. Binary search (iterative)
33. Binary search (recursive)
34. First occurrence of element
35. Last occurrence of element

### Sorting

36. Bubble sort
37. Selection sort
38. Insertion sort
39. Merge sort
40. Quick sort

---

# ğŸªœ LEVEL 5 â€” Recursion & Backtracking

41. Print all subsets
42. Print all permutations
43. Generate parentheses
44. Tower of Hanoi
45. N-Queens
46. Subset sum
47. Power set
48. Word search
49. Combination sum
50. Sudoku solver

---

# ğŸ§© LEVEL 6 â€” Stack & Queue (Borrow checker training)

### Stack

51. Implement stack using `Vec`
52. Valid parentheses
53. Next greater element
54. Reverse stack
55. Min stack

### Queue

56. Implement queue using `VecDeque`
57. Implement queue using two stacks
58. Sliding window maximum
59. First non-repeating character in stream
60. Circular queue

---

# ğŸŒ³ LEVEL 7 â€” Linked List (Ownership boss)

61. Singly linked list (insert, delete)
62. Reverse linked list
63. Detect cycle
64. Find middle of linked list
65. Merge two sorted lists
66. Remove nth node from end
67. Check palindrome linked list
68. Intersection of two lists
69. Flatten linked list
70. Clone linked list with random pointer

---

# ğŸŒ² LEVEL 8 â€” Trees (Recursive thinking)

71. Inorder traversal
72. Preorder traversal
73. Postorder traversal
74. Level order traversal
75. Height of binary tree
76. Diameter of binary tree
77. Check balanced tree
78. Lowest common ancestor
79. Serialize & deserialize tree
80. Convert sorted array to BST

---

# ğŸ—ºï¸ LEVEL 9 â€” Graphs (Ownership + performance)

81. BFS
82. DFS
83. Detect cycle (undirected)
84. Detect cycle (directed)
85. Topological sort
86. Shortest path (BFS)
87. Dijkstra
88. Bellman-Ford
89. Floyd-Warshall
90. Number of islands

---

# ğŸ’° LEVEL 10 â€” Hashing & Heaps

### Hashing

91. Two sum
92. Longest consecutive sequence
93. Subarray with sum zero
94. Frequency sort
95. Group anagrams

### Heap

96. K largest elements
97. K smallest elements
98. Median of stream
99. Merge K sorted lists
100. Top K frequent elements

---

## ğŸ”¥ RULES (IMPORTANT)

* âŒ No `.clone()` unless unavoidable
* âŒ No `.unwrap()` in final solution
* âŒ No global mutable state
* âœ… Use `Option`, `Result`, `match`
* âœ… Prefer ownership transfer over borrowing if simpler

---

